{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home skeleton-ts provides boilerplate for backend project. This project includes: Dependency Injection with InversifyJS Unit test example TypeScript support Hot Reloading Monitoring Per-commit hooks Dockerfile Getting Started git clone git@github.com:darkcl/skeleton-ts.git rm -Rf .git # Start Development make dev","title":"Home"},{"location":"#home","text":"skeleton-ts provides boilerplate for backend project. This project includes: Dependency Injection with InversifyJS Unit test example TypeScript support Hot Reloading Monitoring Per-commit hooks Dockerfile","title":"Home"},{"location":"#getting-started","text":"git clone git@github.com:darkcl/skeleton-ts.git rm -Rf .git # Start Development make dev","title":"Getting Started"},{"location":"about/author/","text":"About Me","title":"Author"},{"location":"about/author/#about-me","text":"","title":"About Me"},{"location":"project-structure/di/","text":"Dependency Injection Dependency Injection is used heavily in skeleton-ts . Dependency Injection provides: Loosely couple in each modules Testable code for each modules Concurrent development for multiple developers Inversion of control Remove any need of singleton object Using InversifyJS Our dependency injection framework is InversifyJS It provides: Easy to implement container object ExpressJS routing annotation with inversify-express-utils Example: New Endpoint With InversifyJS , creating new endpoint will require editing common/container.ts , server.ts and create your controller. // In server.ts import ./controller/todo ; // .. Rest of file ... // In common/container.ts export class AppContainer { constructor () {} public async load () : Promise Container { const container = new Container (); await this . loadMongoDB ( container ); container . bind TodoService ( TYPES . TodoService ). to ( TodoService ); container . bind TodoRepository ( TYPES . TodoRepository ). to ( TodoRepository ); // .. Other Modules ... return container ; } } // In controller/todo.ts @controller ( /todo ) export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService ) { super (); } @httpGet ( / ) public async getTodos ( @response () res : Response ) { const result : DataObject ITodo [] = new DataObject ( await this . todoService . getTodos (), 200 ); res . status ( result . status ). send ( result . asJson ()); } } Example: Middleware Injection If you are using ExpressJS before, you may implement some middleware that modify Request object for controller to use. For example, a locale middleware function localeMiddleware ( req , res , next ) { // Read locale setting from request const locale = Localization . shared ( this . defaultLocale ); const messageStore = locale . of ( req . acceptsLanguages ()); req . messageStore = messageStore ; next (); } This implementation will couple the middleware with controller, made it hard to test. With InversifyJS , we can inject the messageStore to controllers // In server.ts add one more bind in container const container = new Container (); // ... Other Modules ... container . bind LocalizationMiddleware ( TYPES . LocalizationMiddleware ) . to ( LocalizationMiddleware ); const defaultMessage : LocalizedMessage = Localization . shared (). defaultStore (); container . bind LocalizedMessage ( TYPES . LocalizedMessage ) . toConstantValue ( defaultMessage ); // In middleware/localization.middleware.ts @injectable () export class LocalizationMiddleware extends BaseMiddleware { handler ( req : Request , res : Response , next : NextFunction ) : void { const messageStore : LocalizedMessage = this . localeManager . of ( req . acceptsLanguages () ); // Bind LocalizedMessage to container this . bind LocalizedMessage ( TYPES . LocalizedMessage ). toConstantValue ( messageStore ); next (); } constructor ( @inject ( TYPES . Localization ) private localeManager : Localization ) { super (); } } // In controller/todo.ts export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService , @inject ( TYPES . LocalizedMessage ) private messageStore : LocalizedMessage ) { super (); } // ..Other Method... } When testing this controller, you no longer need to mock a request with messageStore , you can directly create an LocalizedMessage with specific locale.","title":"Dependency Injection"},{"location":"project-structure/di/#dependency-injection","text":"Dependency Injection is used heavily in skeleton-ts . Dependency Injection provides: Loosely couple in each modules Testable code for each modules Concurrent development for multiple developers Inversion of control Remove any need of singleton object","title":"Dependency Injection"},{"location":"project-structure/di/#using-inversifyjs","text":"Our dependency injection framework is InversifyJS It provides: Easy to implement container object ExpressJS routing annotation with inversify-express-utils","title":"Using InversifyJS"},{"location":"project-structure/di/#example-new-endpoint","text":"With InversifyJS , creating new endpoint will require editing common/container.ts , server.ts and create your controller. // In server.ts import ./controller/todo ; // .. Rest of file ... // In common/container.ts export class AppContainer { constructor () {} public async load () : Promise Container { const container = new Container (); await this . loadMongoDB ( container ); container . bind TodoService ( TYPES . TodoService ). to ( TodoService ); container . bind TodoRepository ( TYPES . TodoRepository ). to ( TodoRepository ); // .. Other Modules ... return container ; } } // In controller/todo.ts @controller ( /todo ) export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService ) { super (); } @httpGet ( / ) public async getTodos ( @response () res : Response ) { const result : DataObject ITodo [] = new DataObject ( await this . todoService . getTodos (), 200 ); res . status ( result . status ). send ( result . asJson ()); } }","title":"Example: New Endpoint"},{"location":"project-structure/di/#example-middleware-injection","text":"If you are using ExpressJS before, you may implement some middleware that modify Request object for controller to use. For example, a locale middleware function localeMiddleware ( req , res , next ) { // Read locale setting from request const locale = Localization . shared ( this . defaultLocale ); const messageStore = locale . of ( req . acceptsLanguages ()); req . messageStore = messageStore ; next (); } This implementation will couple the middleware with controller, made it hard to test. With InversifyJS , we can inject the messageStore to controllers // In server.ts add one more bind in container const container = new Container (); // ... Other Modules ... container . bind LocalizationMiddleware ( TYPES . LocalizationMiddleware ) . to ( LocalizationMiddleware ); const defaultMessage : LocalizedMessage = Localization . shared (). defaultStore (); container . bind LocalizedMessage ( TYPES . LocalizedMessage ) . toConstantValue ( defaultMessage ); // In middleware/localization.middleware.ts @injectable () export class LocalizationMiddleware extends BaseMiddleware { handler ( req : Request , res : Response , next : NextFunction ) : void { const messageStore : LocalizedMessage = this . localeManager . of ( req . acceptsLanguages () ); // Bind LocalizedMessage to container this . bind LocalizedMessage ( TYPES . LocalizedMessage ). toConstantValue ( messageStore ); next (); } constructor ( @inject ( TYPES . Localization ) private localeManager : Localization ) { super (); } } // In controller/todo.ts export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService , @inject ( TYPES . LocalizedMessage ) private messageStore : LocalizedMessage ) { super (); } // ..Other Method... } When testing this controller, you no longer need to mock a request with messageStore , you can directly create an LocalizedMessage with specific locale.","title":"Example: Middleware Injection"},{"location":"project-structure/overview/","text":"Project Structure Overview mermaid.initialize({startOnLoad:true}); Folder Structure app \u251c\u2500\u2500 common \u2502 \u2514\u2500\u2500 { App Container, Common Module, e.g. Data Object } \u251c\u2500\u2500 constant \u2502 \u2514\u2500\u2500 { Constant Variable, e.g. DI Types } \u251c\u2500\u2500 controller \u2502 \u2514\u2500\u2500 { Controllers, e.g. TodoController } \u251c\u2500\u2500 locale \u2502 \u2514\u2500\u2500 { Locale Releated Resources } \u251c\u2500\u2500 middleware \u2502 \u2514\u2500\u2500 { Middlewares, e.g. LocaleMiddleware } \u251c\u2500\u2500 repositories \u2502 \u2514\u2500\u2500 { Repositories , e.g. TodoRepository} \u251c\u2500\u2500 server.ts \u251c\u2500\u2500 service \u2502 \u2514\u2500\u2500 { Services, e.g. TodoService } \u2514\u2500\u2500 utils \u2514\u2500\u2500 { Utitlities, e.g. MongoConnection } Relationship between modules Global Scope graph LR id1[server.ts]-->id2[Setup Project Modules] id1-->id3[Setup Global Middleware] id2-->id4[Controller] id2-->id5[Service] id2-->id6[Repository] id2-->id7[Middleware] id3-->id8[CORS] id3-->id9[Helmet] id3-->id10[Logger] Domain Scope graph TB a[User Request]-->id0[Middleware] id0-->id1[Controller] id1-->|Uses|id2[Service] id2-->|Result|id1 id2-->|Uses|id3[Repository] id2-->|Uses|id4[Utility] id3-->|Query|id5[Persistence Data] id4-->|Interact|id6[Thrid-party Data]","title":"Overview"},{"location":"project-structure/overview/#project-structure-overview","text":"mermaid.initialize({startOnLoad:true});","title":"Project Structure Overview"},{"location":"project-structure/overview/#folder-structure","text":"app \u251c\u2500\u2500 common \u2502 \u2514\u2500\u2500 { App Container, Common Module, e.g. Data Object } \u251c\u2500\u2500 constant \u2502 \u2514\u2500\u2500 { Constant Variable, e.g. DI Types } \u251c\u2500\u2500 controller \u2502 \u2514\u2500\u2500 { Controllers, e.g. TodoController } \u251c\u2500\u2500 locale \u2502 \u2514\u2500\u2500 { Locale Releated Resources } \u251c\u2500\u2500 middleware \u2502 \u2514\u2500\u2500 { Middlewares, e.g. LocaleMiddleware } \u251c\u2500\u2500 repositories \u2502 \u2514\u2500\u2500 { Repositories , e.g. TodoRepository} \u251c\u2500\u2500 server.ts \u251c\u2500\u2500 service \u2502 \u2514\u2500\u2500 { Services, e.g. TodoService } \u2514\u2500\u2500 utils \u2514\u2500\u2500 { Utitlities, e.g. MongoConnection }","title":"Folder Structure"},{"location":"project-structure/overview/#relationship-between-modules","text":"","title":"Relationship between modules"},{"location":"project-structure/overview/#global-scope","text":"graph LR id1[server.ts]-->id2[Setup Project Modules] id1-->id3[Setup Global Middleware] id2-->id4[Controller] id2-->id5[Service] id2-->id6[Repository] id2-->id7[Middleware] id3-->id8[CORS] id3-->id9[Helmet] id3-->id10[Logger]","title":"Global Scope"},{"location":"project-structure/overview/#domain-scope","text":"graph TB a[User Request]-->id0[Middleware] id0-->id1[Controller] id1-->|Uses|id2[Service] id2-->|Result|id1 id2-->|Uses|id3[Repository] id2-->|Uses|id4[Utility] id3-->|Query|id5[Persistence Data] id4-->|Interact|id6[Thrid-party Data]","title":"Domain Scope"},{"location":"workflow/deployment/","text":"Deployment","title":"Deployment"},{"location":"workflow/deployment/#deployment","text":"","title":"Deployment"},{"location":"workflow/development/","text":"Development After writing your documentation, you can start implementation. Listing the dependency Before implementation, it is always good to list out what dependency you will use. You may ask: Does this new feature relate to any existing Controller , Service or Repository ? Any new third-party library you will use? Any sharable logic (e.g. Rate Limiting, Localization)? Update application container Adding Middleware Adding Controller Adding Service Adding Repository Working with third-party library Pattern to avoid Singleton Adding value to request object","title":"Development"},{"location":"workflow/development/#development","text":"After writing your documentation, you can start implementation.","title":"Development"},{"location":"workflow/development/#listing-the-dependency","text":"Before implementation, it is always good to list out what dependency you will use. You may ask: Does this new feature relate to any existing Controller , Service or Repository ? Any new third-party library you will use? Any sharable logic (e.g. Rate Limiting, Localization)?","title":"Listing the dependency"},{"location":"workflow/development/#update-application-container","text":"","title":"Update application container"},{"location":"workflow/development/#adding-middleware","text":"","title":"Adding Middleware"},{"location":"workflow/development/#adding-controller","text":"","title":"Adding Controller"},{"location":"workflow/development/#adding-service","text":"","title":"Adding Service"},{"location":"workflow/development/#adding-repository","text":"","title":"Adding Repository"},{"location":"workflow/development/#working-with-third-party-library","text":"","title":"Working with third-party library"},{"location":"workflow/development/#pattern-to-avoid","text":"","title":"Pattern to avoid"},{"location":"workflow/development/#singleton","text":"","title":"Singleton"},{"location":"workflow/development/#adding-value-to-request-object","text":"","title":"Adding value to request object"},{"location":"workflow/doc/","text":"Writing Documentation Documentation is the first step to implenent an enpoint. In this project, we are using API Blueprint It provides: Clean Syntax for defining RESTful API Specification Great tooling including mock server and static site generation Integretion tests using API blueprint Example: Todo Specification This section will cover how to define a basic Todo endpoint Meta Data The meta data define your API name and API Blueprint version. FORMAT: 1A # skeleton-ts Group A group is a group for RESTful resources. In this example, it is Todo . # Group Todo Resources related to Todo in the API. Collection Collection is collection of endpoint, in this case, it is /todo ## Todo Collection [/todo] Actions This is the actions for the collection, for example, getting todo list ### Get Todo List [GET] - Response 200 - Attribute (Todo List Response) You can also over-ride the endpoint ### Get Todo List [GET /todo/{id}] - Parameters - id: `123` (string) Todo Item ID - Response 200 - Attribute (Todo Response) Data Structures In this section you can define what a respone / request object looks like ## Todo Base (object) - description: `Hello World!` (string) Todo item description You can also define nested object ## Todo List Response (object) - meta (object) - status: 200 (number) - contents (array[Todo Base]) Example: Documentation Website With aglio , you can generate a static html web page for your API spec. Run the following command in this project to generate the web page. make doc Example: Mock Server If your team start development for frontend or other module with the backend at the same time. Mocking will be very useful to speed up your team development speed. drakov is include in this project you can start a mock server with your API spec with make mock","title":"Writing Documentation"},{"location":"workflow/doc/#writing-documentation","text":"Documentation is the first step to implenent an enpoint. In this project, we are using API Blueprint It provides: Clean Syntax for defining RESTful API Specification Great tooling including mock server and static site generation Integretion tests using API blueprint","title":"Writing Documentation"},{"location":"workflow/doc/#example-todo-specification","text":"This section will cover how to define a basic Todo endpoint","title":"Example: Todo Specification"},{"location":"workflow/doc/#meta-data","text":"The meta data define your API name and API Blueprint version. FORMAT: 1A # skeleton-ts","title":"Meta Data"},{"location":"workflow/doc/#group","text":"A group is a group for RESTful resources. In this example, it is Todo . # Group Todo Resources related to Todo in the API.","title":"Group"},{"location":"workflow/doc/#collection","text":"Collection is collection of endpoint, in this case, it is /todo ## Todo Collection [/todo]","title":"Collection"},{"location":"workflow/doc/#actions","text":"This is the actions for the collection, for example, getting todo list ### Get Todo List [GET] - Response 200 - Attribute (Todo List Response) You can also over-ride the endpoint ### Get Todo List [GET /todo/{id}] - Parameters - id: `123` (string) Todo Item ID - Response 200 - Attribute (Todo Response)","title":"Actions"},{"location":"workflow/doc/#data-structures","text":"In this section you can define what a respone / request object looks like ## Todo Base (object) - description: `Hello World!` (string) Todo item description You can also define nested object ## Todo List Response (object) - meta (object) - status: 200 (number) - contents (array[Todo Base])","title":"Data Structures"},{"location":"workflow/doc/#example-documentation-website","text":"With aglio , you can generate a static html web page for your API spec. Run the following command in this project to generate the web page. make doc","title":"Example: Documentation Website"},{"location":"workflow/doc/#example-mock-server","text":"If your team start development for frontend or other module with the backend at the same time. Mocking will be very useful to speed up your team development speed. drakov is include in this project you can start a mock server with your API spec with make mock","title":"Example: Mock Server"},{"location":"workflow/integration-testing/","text":"Integretion Test","title":"Integration Testing"},{"location":"workflow/integration-testing/#integretion-test","text":"","title":"Integretion Test"},{"location":"workflow/monitoring/","text":"Monitoring Graphite ELK Stack Grafana","title":"Monitoring"},{"location":"workflow/monitoring/#monitoring","text":"","title":"Monitoring"},{"location":"workflow/monitoring/#graphite","text":"","title":"Graphite"},{"location":"workflow/monitoring/#elk-stack","text":"","title":"ELK Stack"},{"location":"workflow/monitoring/#grafana","text":"","title":"Grafana"},{"location":"workflow/overview/","text":"Workflow Overview This is a complete workflow on creating new backend endpoints with skeleton-ts Writing Documentations Development Unit Testing Integration Testing Deployment Monitoring","title":"Overview"},{"location":"workflow/overview/#workflow-overview","text":"This is a complete workflow on creating new backend endpoints with skeleton-ts Writing Documentations Development Unit Testing Integration Testing Deployment Monitoring","title":"Workflow Overview"},{"location":"workflow/unit-testing/","text":"Unit Test What to test? Mocking Spying","title":"Unit Testing"},{"location":"workflow/unit-testing/#unit-test","text":"","title":"Unit Test"},{"location":"workflow/unit-testing/#what-to-test","text":"","title":"What to test?"},{"location":"workflow/unit-testing/#mocking","text":"","title":"Mocking"},{"location":"workflow/unit-testing/#spying","text":"","title":"Spying"}]}