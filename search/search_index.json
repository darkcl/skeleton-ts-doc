{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home skeleton-ts provides boilerplate for backend project. This project includes: Dependency Injection with InversifyJS Unit test example TypeScript support Hot Reloading Monitoring Per-commit hooks Dockerfile Getting Started git clone git@github.com:darkcl/skeleton-ts.git rm -Rf .git # Start Development make dev","title":"Home"},{"location":"#home","text":"skeleton-ts provides boilerplate for backend project. This project includes: Dependency Injection with InversifyJS Unit test example TypeScript support Hot Reloading Monitoring Per-commit hooks Dockerfile","title":"Home"},{"location":"#getting-started","text":"git clone git@github.com:darkcl/skeleton-ts.git rm -Rf .git # Start Development make dev","title":"Getting Started"},{"location":"about/author/","text":"About Me","title":"Author"},{"location":"about/author/#about-me","text":"","title":"About Me"},{"location":"project-structure/di/","text":"Dependency Injection Dependency Injection is used heavily in skeleton-ts . Dependency Injection provides: Loosely couple in each modules Testable code for each modules Concurrent development for multiple developers Inverse of control Remove any need of singleton object Using InversifyJS Our dependency injection framework is InversifyJS It provides: Easy to implement container object ExpressJS routing annotation with inversify-express-utils Example: New Endpoint With InversifyJS , creating new endpoint will on require editing 2 files // In server.ts import ./controller/todo ; ( async () = { // Connect to MongoDB await MongoDBConnection . connect (); // Load everything needed to the Container const container = new Container (); container . bind TodoService ( TYPES . TodoService ). to ( TodoService ); container . bind TodoRepository ( TYPES . TodoRepository ). to ( TodoRepository ); // Start the server const server = new InversifyExpressServer ( container , null , { rootPath : /api/v1 }); server . setConfig ( app = { app . use ( bodyParser . urlencoded ({ extended : true }) ); }); server . setErrorConfig ( app = { // Error Logger const errorMiddleware : ErrorMiddleware = new ErrorMiddleware (); app . use ( errorMiddleware . process ()); }); const serverInstance = server . build (); const port : string = process . env . PORT || 3000 ; serverInstance . listen ( parseInt ( port )); })(); // In controller/todo.ts @controller ( /todo ) export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService ) { super (); } @httpGet ( / ) public async getTodos ( @response () res : Response ) { const result : DataObject ITodo [] = new DataObject ( await this . todoService . getTodos (), 200 ); res . status ( result . status ). send ( result . asJson ()); } } Example: Middleware Injection If you are using ExpressJS before, you may implement some middleware that modify Request object for controller to use. For example, a locale middleware function localeMiddleware ( req , res , next ) { // Read locale setting from request const locale = Localization . shared ( this . defaultLocale ); const messageStore = locale . of ( req . acceptsLanguages ()); req . messageStore = messageStore ; next (); } This implementation will couple the middleware with controller, made it hard to test. With InversifyJS , we can inject the messageStore to controllers // In server.ts add one more bind in container const container = new Container (); // ... Other Modules ... container . bind LocalizationMiddleware ( TYPES . LocalizationMiddleware ) . to ( LocalizationMiddleware ); const defaultMessage : LocalizedMessage = Localization . shared (). defaultStore (); container . bind LocalizedMessage ( TYPES . LocalizedMessage ) . toConstantValue ( defaultMessage ); // In middleware/localization.middleware.ts @injectable () export class LocalizationMiddleware extends BaseMiddleware { handler ( req : Request , res : Response , next : NextFunction ) : void { const locale : Localization = Localization . shared ( this . defaultLocale ); const messageStore : LocalizedMessage = locale . of ( req . acceptsLanguages ()); // Bind LocalizedMessage to container this . bind LocalizedMessage ( TYPES . LocalizedMessage ). toConstantValue ( messageStore ); next (); } constructor ( private defaultLocale : string ) { super (); } } // In controller/todo.ts export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService , @inject ( TYPES . LocalizedMessage ) private messageStore : LocalizedMessage ) { super (); } // ..Other Method... } When testing this controller, you no longer need to mock a request with messageStore , you can directly create an LocalizedMessage with specific locale.","title":"Dependency Injection"},{"location":"project-structure/di/#dependency-injection","text":"Dependency Injection is used heavily in skeleton-ts . Dependency Injection provides: Loosely couple in each modules Testable code for each modules Concurrent development for multiple developers Inverse of control Remove any need of singleton object","title":"Dependency Injection"},{"location":"project-structure/di/#using-inversifyjs","text":"Our dependency injection framework is InversifyJS It provides: Easy to implement container object ExpressJS routing annotation with inversify-express-utils","title":"Using InversifyJS"},{"location":"project-structure/di/#example-new-endpoint","text":"With InversifyJS , creating new endpoint will on require editing 2 files // In server.ts import ./controller/todo ; ( async () = { // Connect to MongoDB await MongoDBConnection . connect (); // Load everything needed to the Container const container = new Container (); container . bind TodoService ( TYPES . TodoService ). to ( TodoService ); container . bind TodoRepository ( TYPES . TodoRepository ). to ( TodoRepository ); // Start the server const server = new InversifyExpressServer ( container , null , { rootPath : /api/v1 }); server . setConfig ( app = { app . use ( bodyParser . urlencoded ({ extended : true }) ); }); server . setErrorConfig ( app = { // Error Logger const errorMiddleware : ErrorMiddleware = new ErrorMiddleware (); app . use ( errorMiddleware . process ()); }); const serverInstance = server . build (); const port : string = process . env . PORT || 3000 ; serverInstance . listen ( parseInt ( port )); })(); // In controller/todo.ts @controller ( /todo ) export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService ) { super (); } @httpGet ( / ) public async getTodos ( @response () res : Response ) { const result : DataObject ITodo [] = new DataObject ( await this . todoService . getTodos (), 200 ); res . status ( result . status ). send ( result . asJson ()); } }","title":"Example: New Endpoint"},{"location":"project-structure/di/#example-middleware-injection","text":"If you are using ExpressJS before, you may implement some middleware that modify Request object for controller to use. For example, a locale middleware function localeMiddleware ( req , res , next ) { // Read locale setting from request const locale = Localization . shared ( this . defaultLocale ); const messageStore = locale . of ( req . acceptsLanguages ()); req . messageStore = messageStore ; next (); } This implementation will couple the middleware with controller, made it hard to test. With InversifyJS , we can inject the messageStore to controllers // In server.ts add one more bind in container const container = new Container (); // ... Other Modules ... container . bind LocalizationMiddleware ( TYPES . LocalizationMiddleware ) . to ( LocalizationMiddleware ); const defaultMessage : LocalizedMessage = Localization . shared (). defaultStore (); container . bind LocalizedMessage ( TYPES . LocalizedMessage ) . toConstantValue ( defaultMessage ); // In middleware/localization.middleware.ts @injectable () export class LocalizationMiddleware extends BaseMiddleware { handler ( req : Request , res : Response , next : NextFunction ) : void { const locale : Localization = Localization . shared ( this . defaultLocale ); const messageStore : LocalizedMessage = locale . of ( req . acceptsLanguages ()); // Bind LocalizedMessage to container this . bind LocalizedMessage ( TYPES . LocalizedMessage ). toConstantValue ( messageStore ); next (); } constructor ( private defaultLocale : string ) { super (); } } // In controller/todo.ts export class TodoController extends BaseHttpController { constructor ( @inject ( TYPES . TodoService ) private todoService : TodoService , @inject ( TYPES . LocalizedMessage ) private messageStore : LocalizedMessage ) { super (); } // ..Other Method... } When testing this controller, you no longer need to mock a request with messageStore , you can directly create an LocalizedMessage with specific locale.","title":"Example: Middleware Injection"},{"location":"project-structure/overview/","text":"Overview mermaid.initialize({startOnLoad:true}); Folder Structure app \u251c\u2500\u2500 common \u2502 \u2514\u2500\u2500 { Common Module, e.g. Data Object } \u251c\u2500\u2500 constant \u2502 \u2514\u2500\u2500 { Constant Variable, e.g. DI Types } \u251c\u2500\u2500 controller \u2502 \u2514\u2500\u2500 { Controllers, e.g. TodoController } \u251c\u2500\u2500 locale \u2502 \u2514\u2500\u2500 { Locale Releated Resources } \u251c\u2500\u2500 middleware \u2502 \u2514\u2500\u2500 { Middlewares, e.g. LocaleMiddleware } \u251c\u2500\u2500 repositories \u2502 \u2514\u2500\u2500 { Repositories , e.g. TodoRepository} \u251c\u2500\u2500 server.ts \u251c\u2500\u2500 service \u2502 \u2514\u2500\u2500 { Services, e.g. TodoService } \u2514\u2500\u2500 utils \u2514\u2500\u2500 { Utitlities, e.g. MongoConnection } Relationship between modules Global Scope graph LR id1[server.ts]-->id2[Setup Project Modules] id1-->id3[Setup Global Middleware] id2-->id4[Controller] id2-->id5[Service] id2-->id6[Repository] id2-->id7[Middleware] id3-->id8[CORS] id3-->id9[Helmet] id3-->id10[Logger] Domain Scope graph TB a[User Request]-->id0[Middleware] id0-->id1[Controller] id1-->|Uses|id2[Service] id2-->|Result|id1 id2-->|Uses|id3[Repository] id2-->|Uses|id4[Utility] id3-->|Query|id5[Persistence Data] id4-->|Interact|id6[Thrid-party Data]","title":"Overview"},{"location":"project-structure/overview/#overview","text":"mermaid.initialize({startOnLoad:true});","title":"Overview"},{"location":"project-structure/overview/#folder-structure","text":"app \u251c\u2500\u2500 common \u2502 \u2514\u2500\u2500 { Common Module, e.g. Data Object } \u251c\u2500\u2500 constant \u2502 \u2514\u2500\u2500 { Constant Variable, e.g. DI Types } \u251c\u2500\u2500 controller \u2502 \u2514\u2500\u2500 { Controllers, e.g. TodoController } \u251c\u2500\u2500 locale \u2502 \u2514\u2500\u2500 { Locale Releated Resources } \u251c\u2500\u2500 middleware \u2502 \u2514\u2500\u2500 { Middlewares, e.g. LocaleMiddleware } \u251c\u2500\u2500 repositories \u2502 \u2514\u2500\u2500 { Repositories , e.g. TodoRepository} \u251c\u2500\u2500 server.ts \u251c\u2500\u2500 service \u2502 \u2514\u2500\u2500 { Services, e.g. TodoService } \u2514\u2500\u2500 utils \u2514\u2500\u2500 { Utitlities, e.g. MongoConnection }","title":"Folder Structure"},{"location":"project-structure/overview/#relationship-between-modules","text":"","title":"Relationship between modules"},{"location":"project-structure/overview/#global-scope","text":"graph LR id1[server.ts]-->id2[Setup Project Modules] id1-->id3[Setup Global Middleware] id2-->id4[Controller] id2-->id5[Service] id2-->id6[Repository] id2-->id7[Middleware] id3-->id8[CORS] id3-->id9[Helmet] id3-->id10[Logger]","title":"Global Scope"},{"location":"project-structure/overview/#domain-scope","text":"graph TB a[User Request]-->id0[Middleware] id0-->id1[Controller] id1-->|Uses|id2[Service] id2-->|Result|id1 id2-->|Uses|id3[Repository] id2-->|Uses|id4[Utility] id3-->|Query|id5[Persistence Data] id4-->|Interact|id6[Thrid-party Data]","title":"Domain Scope"},{"location":"workflow/doc/","text":"Writing Documentation","title":"Writing Documentation"},{"location":"workflow/doc/#writing-documentation","text":"","title":"Writing Documentation"}]}